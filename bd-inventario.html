<!-- bd-relacional.html -->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proyecto Base de Datos Relacional</title>
  <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body class="bd-proyecto">
<header>
  <h1>Sistema de Inventario con Base de Datos Relacional</h1>
  <a href="index.html" class="btn-volver">‚Üê Volver al Portafolio</a>
</header>

<main>
  <section class="intro">
    <h2>Objetivo del Proyecto</h2>
    <p>
      Este proyecto consisti√≥ en dise√±ar e implementar un <strong>sistema de inventario</strong> basado en una <strong>base de datos relacional utilizando PostgreSQL</strong>.
      El sistema permite registrar productos, proveedores y transacciones de forma estructurada y segura, aplicando buenas pr√°cticas como:
    </p>
    <ul>
      <li>Uso de <strong>claves primarias y for√°neas</strong> para establecer relaciones.</li>
      <li><strong>Normalizaci√≥n</strong> hasta la Tercera Forma Normal (3FN).</li>
      <li>Aplicaci√≥n de <strong>transacciones SQL</strong> para mantener la integridad.</li>
      <li>Implementaci√≥n de <strong>consultas complejas</strong> y <strong>triggers</strong>.</li>
    </ul>
  </section>

  <section>
    <h2>Modelo Entidad-Relaci√≥n (ERD)</h2>
    <img src="assets/img/diagrama-erd.png" alt="Diagrama ERD del sistema" class="img-responsive">
    <p>
      El diagrama ERD muestra tres entidades principales: <strong>Productos</strong>, <strong>Proveedores</strong> y <strong>Transacciones</strong>.
      Cada producto est√° asociado a un proveedor, y las transacciones registran operaciones (compra o venta) que afectan el inventario.
    </p>
  </section>

  <section>
    <h2>Estructura de Tablas en PostgreSQL</h2>
    <img src="assets/img/consultas-sql.png" alt="Tablas creadas en PostgreSQL" class="img-responsive">
    <p>
      Se crearon tres tablas principales:
    </p>
    <ul>
      <li><strong>productos</strong>: contiene nombre, descripci√≥n, precio y cantidad.</li>
      <li><strong>proveedores</strong>: almacena los datos de contacto de los proveedores.</li>
      <li><strong>transacciones</strong>: registra las operaciones de compra/venta, incluyendo la fecha y el producto involucrado.</li>
    </ul>
    <p>
      Cada tabla fue dise√±ada con sus respectivas <strong>claves primarias</strong> y se utilizaron <strong>claves for√°neas</strong> para vincular las relaciones entre ellas.
    </p>
    <p>
      Se utilizaron <strong>claves primarias</strong> (como <code>producto_id</code> o <code>proveedor_id</code>) y <strong>claves for√°neas</strong> para relacionar las tablas. Tambi√©n se agregaron restricciones como:
    </p>

    <ul>
      <li><code>CHECK</code> para asegurar que el precio sea mayor a 0 o que la cantidad no sea negativa.</li>
      <li><code>DEFAULT CURRENT_TIMESTAMP</code> para que la fecha se registre autom√°ticamente.</li>
      <li><code>NOT NULL</code> y <code>UNIQUE</code> para mantener integridad y evitar duplicados en campos clave.</li>
    </ul>

    <a href="assets/img/creacion-tablas-sql.png" target="_blank" class="btn-ver">üìé Ver creaci√≥n de tablas completa</a>  </section>
  <section>
    <h2>Registro de Transacciones</h2>
    <img src="assets/img/transacciones.png" alt="Transacciones en PostgreSQL" class="img-responsive">
    <p>
      Las transacciones permiten simular operaciones comerciales reales. Por ejemplo:
    </p>
    <ul>
      <li>Una <strong>compra</strong> aumenta el stock de un producto.</li>
      <li>Una <strong>venta</strong> disminuye el stock.</li>
    </ul>
    <p>
      Esto se logr√≥ mediante el uso de <strong>triggers y funciones SQL</strong>, que modifican autom√°ticamente la cantidad de inventario cada vez que se realiza una transacci√≥n.
    </p>
  </section>
  <section>
    <h2>Triggers y Automatizaci√≥n del Inventario</h2>
    <img src="assets/img/triggers-funcion-sql.png" alt="Trigger SQL para actualizar stock" class="img-responsive">
    <p>
      Para asegurar que el <strong>inventario se actualice autom√°ticamente</strong> al registrar una compra o venta, se cre√≥ una <strong>funci√≥n en PostgreSQL</strong> llamada <code>actualizar_stock()</code>, junto a un <strong>trigger</strong> que se ejecuta cada vez que se inserta una nueva fila en la tabla <code>transacciones</code>.
    </p>

    <p>
      La funci√≥n revisa si la transacci√≥n es una <strong>compra</strong> (se suma stock) o una <strong>venta</strong> (se descuenta stock). En el caso de una venta, adem√°s valida que haya stock suficiente; si no, lanza una excepci√≥n.
    </p>

    <p>
      Este tipo de l√≥gica garantiza la <strong>integridad de los datos</strong>, evita errores humanos y automatiza una parte clave del sistema.
    </p>

    <a href="assets/img/triggers-funcion-sql.png" target="_blank" class="btn-ver"> Ver Trigger en tama√±o completo</a>
  </section>

  <section>
    <h2>Consultas SQL</h2>
    <img src="assets/img/consulta-sql.png" alt="Consultas SQL" class="img-responsive">
    <p>
      Se crearon consultas para obtener informaci√≥n √∫til del sistema, tales como:
    </p>
    <ul>
      <li>Productos y sus proveedores.</li>
      <li>Transacciones realizadas en el d√≠a actual.</li>
      <li>Productos con inventario bajo o agotado.</li>
      <li>Proveedores que han participado en transacciones.</li>
    </ul>
    <p>
      Estas consultas demuestran el uso de <strong>SELECT con JOIN</strong>, <strong>filtros con WHERE</strong>, <strong>agrupaciones con GROUP BY</strong> y <strong>funciones agregadas</strong>.
    </p>
  </section>

  <section id="normalizacion" class="container my-5">
    <h2 class="text-center mb-4">Normalizaci√≥n</h2>
    <div class="card shadow p-4">
      <p>
        Para evitar duplicaci√≥n de datos y asegurar su integridad, se aplic√≥ <strong>normalizaci√≥n hasta la Tercera Forma Normal (3FN)</strong>.
      </p>
      <ul>
        <li>Se separaron las entidades: productos, proveedores y transacciones.</li>
        <li>Se eliminaron datos redundantes, como proveedores repetidos.</li>
        <li>Se utilizaron <strong>claves for√°neas</strong> para relacionar las tablas sin duplicar informaci√≥n.</li>
      </ul>
      <p>
        La siguiente consulta (con error intencional) muestra un intento de JOIN que refleja la estructura normalizada:
      </p>

      <pre class="bg-light p-3 rounded"><code>
SELECT p.nombre AS producto, pr.nombre AS proveedor
FROM productos p
JOIN proveedores pr ON p.proveedor_id = pr.proveedor_id;
      </code></pre>

      <p>
        Aunque el campo <code>proveedor_id</code> no estaba en la tabla productos (de ah√≠ el error), la intenci√≥n demuestra que los datos est√°n <strong>relacionados</strong> mediante claves externas y no se repiten dentro de una sola tabla. Esto es caracter√≠stico de una base de datos bien normalizada.
      </p>

      <img src="assets/img/normalizacion-error.png" alt="Consulta JOIN con error de clave" class="img-fluid rounded shadow my-3">

      <p>
        Gracias a la normalizaci√≥n, es posible actualizar proveedores o productos en un solo lugar, sin inconsistencias en otras partes del sistema.
      </p>
    </div>
  </section>

  <section>
    <h2>Conclusi√≥n Personal</h2>
    <p>
      Este proyecto me permiti√≥ aplicar en un contexto real lo aprendido sobre dise√±o e implementaci√≥n de bases de datos relacionales. Desde el modelado inicial hasta las consultas y automatizaciones con SQL, comprend√≠ la importancia de una estructura bien dise√±ada para el manejo eficiente de datos.
      Adem√°s, reforc√© el uso de herramientas como PostgreSQL, DBeaver y el dise√±o visual de diagramas ERD.
    </p>
  </section>
</main>

<footer>
  <p>Proyecto desarrollado por Magdalena Inalaf G. ‚Äî Bootcamp JS 2025</p>
</footer>
</body>
</html>
